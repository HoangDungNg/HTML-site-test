<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Treasure Quest</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: "Arial", sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }

      .game-container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }

      .game-header {
        text-align: center;
        color: white;
        margin-bottom: 20px;
      }

      .game-header h1 {
        margin: 0;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .stats {
        display: flex;
        justify-content: space-between;
        color: white;
        font-size: 1.2em;
        margin-bottom: 10px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      #gameCanvas {
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        background: linear-gradient(45deg, #2c3e50, #34495e);
        display: block;
        box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.3);
      }

      .controls {
        text-align: center;
        color: white;
        margin-top: 15px;
        font-size: 0.9em;
        opacity: 0.8;
      }

      .victory-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff9a9e, #fecfef);
        color: #333;
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        display: none;
        z-index: 1000;
        animation: victoryPulse 2s infinite;
      }

      @keyframes victoryPulse {
        0%,
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.05);
        }
      }

      .victory-message h2 {
        margin: 0 0 20px 0;
        font-size: 2.5em;
        color: #e74c3c;
      }

      .victory-message p {
        font-size: 1.3em;
        margin: 10px 0;
        line-height: 1.5;
      }

      .play-again-btn {
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-size: 1.1em;
        cursor: pointer;
        margin-top: 20px;
        transition: transform 0.2s;
      }

      .play-again-btn:hover {
        transform: scale(1.05);
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="game-header">
        <h1 style="margin-bottom: 20px">üè¥‚Äç‚ò†Ô∏è Treasure Quest üíé</h1>
        <div class="stats">
          <span>ƒêi·ªÉm: <span id="score">0</span></span>
          <span>M·∫°ng s·ªëng: <span id="lives">3</span></span>
          <span>T√†i nguy√™n thu th·∫≠p: <span id="treasures">0</span>/5</span>
          <span>Th·ªùi gian: <span id="timer">60</span>s</span>
          <span>Level: <span id="level">1</span></span>
        </div>
      </div>

      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <div class="controls">
        X√†i WASD ho·∫∑c c√°c ph√≠m m≈©i t√™n ƒë·ªÉ ch∆°i game n√†y trong 60 gi√¢y <br />
        üü° T√†i nguy√™n c∆° b·∫£n (100 pts) ‚Ä¢ üü† T√†i nguy√™n ƒë·∫∑c bi·ªát (150 pts) ‚Ä¢ Nh·ªõ
        n√© m·∫•y con m√†u ƒë·ªè v√† c·ª•c ƒë√° m√†u x√°m!
      </div>
    </div>

    <div class="victory-message" id="victoryMessage">
      <h2>üéâ VICTORY! üéâ</h2>
      <p>üåü Ch√∫c m·ª´ng m·ªπ n·ªØ ƒë√£ win üåü</p>
      <p>V·ª´a h·ªçc gi·ªèi v·ª´a ch∆°i game gi·ªèi ai m√† ch·ªãu n·ªïi</p>
      <p>
        T√†i nƒÉng n√†y c·ªßa n√†ng s·∫Ω gi√∫p n√†ng thi c·ª≠ ƒë·∫°t 10 ƒëi·ªÉm t·∫•t c·∫£ c√°c m√¥n ‚ú®
      </p>
      <p>Final Score: <span id="finalScore">0</span></p>
      <button class="play-again-btn" onclick="restartGame()">Play Again</button>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game state
      let gameState = {
        score: 0,
        lives: 3,
        treasuresCollected: 0,
        gameWon: false,
        gameOver: false,
        level: 1,
        timeLeft: 60,
      };

      // Player object
      const player = {
        x: 50,
        y: 300,
        width: 30,
        height: 30,
        speed: 5,
        color: "#3498db",
      };

      // Treasures array
      let treasures = [];

      // Enemies array
      let enemies = [];

      // Obstacles array
      let obstacles = [];

      // Timer for game countdown
      let gameTimer;

      // Moving treasures
      let movingTreasures = [];

      // Initialize treasures
      function createTreasures() {
        treasures = [];
        movingTreasures = [];

        // Create 3 static treasures
        treasures.push({
          x: 150,
          y: 100,
          width: 25,
          height: 25,
          collected: false,
          type: "static",
        });
        treasures.push({
          x: 400,
          y: 500,
          width: 25,
          height: 25,
          collected: false,
          type: "static",
        });
        treasures.push({
          x: 650,
          y: 150,
          width: 25,
          height: 25,
          collected: false,
          type: "static",
        });

        // Create 2 moving treasures
        movingTreasures.push({
          x: 300,
          y: 300,
          width: 25,
          height: 25,
          collected: false,
          speedX: 2,
          speedY: 1.5,
          type: "moving",
        });
        movingTreasures.push({
          x: 500,
          y: 200,
          width: 25,
          height: 25,
          collected: false,
          speedX: -1.5,
          speedY: 2.5,
          type: "moving",
        });
      }

      // Initialize enemies
      function createEnemies() {
        enemies = [];
        const enemyCount = 3 + gameState.level; // More enemies each level

        for (let i = 0; i < enemyCount; i++) {
          enemies.push({
            x: 150 + i * 120,
            y: 250 + (i % 3) * 100,
            width: 25,
            height: 25,
            speedX: (Math.random() - 0.5) * (2 + gameState.level),
            speedY: (Math.random() - 0.5) * (2 + gameState.level),
            color: "#e74c3c",
            followPlayer: i % 2 === 0, // Every other enemy follows player
          });
        }
      }

      // Create obstacles
      function createObstacles() {
        obstacles = [];
        for (let i = 0; i < 6; i++) {
          obstacles.push({
            x: 100 + i * 120,
            y: 200 + (i % 2) * 200,
            width: 40,
            height: 40,
            color: "#34495e",
          });
        }
      }

      // Input handling
      const keys = {};

      document.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;
      });

      document.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });

      // Update player position
      function updatePlayer() {
        if (keys["w"] || keys["arrowup"]) {
          player.y = Math.max(0, player.y - player.speed);
        }
        if (keys["s"] || keys["arrowdown"]) {
          player.y = Math.min(
            canvas.height - player.height,
            player.y + player.speed
          );
        }
        if (keys["a"] || keys["arrowleft"]) {
          player.x = Math.max(0, player.x - player.speed);
        }
        if (keys["d"] || keys["arrowright"]) {
          player.x = Math.min(
            canvas.width - player.width,
            player.x + player.speed
          );
        }
      }

      // Update enemies
      function updateEnemies() {
        enemies.forEach((enemy) => {
          if (enemy.followPlayer) {
            // Smart enemy that follows player
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0) {
              enemy.x += (dx / distance) * Math.abs(enemy.speedX);
              enemy.y += (dy / distance) * Math.abs(enemy.speedY);
            }
          } else {
            // Regular bouncing enemy
            enemy.x += enemy.speedX;
            enemy.y += enemy.speedY;
          }

          // Bounce off walls
          if (enemy.x <= 0 || enemy.x >= canvas.width - enemy.width) {
            enemy.speedX *= -1;
          }
          if (enemy.y <= 0 || enemy.y >= canvas.height - enemy.height) {
            enemy.speedY *= -1;
          }

          // Keep enemies in bounds
          enemy.x = Math.max(0, Math.min(canvas.width - enemy.width, enemy.x));
          enemy.y = Math.max(
            0,
            Math.min(canvas.height - enemy.height, enemy.y)
          );
        });
      }

      // Update moving treasures
      function updateMovingTreasures() {
        movingTreasures.forEach((treasure) => {
          if (!treasure.collected) {
            treasure.x += treasure.speedX;
            treasure.y += treasure.speedY;

            // Bounce off walls
            if (
              treasure.x <= 0 ||
              treasure.x >= canvas.width - treasure.width
            ) {
              treasure.speedX *= -1;
            }
            if (
              treasure.y <= 0 ||
              treasure.y >= canvas.height - treasure.height
            ) {
              treasure.speedY *= -1;
            }

            // Keep in bounds
            treasure.x = Math.max(
              0,
              Math.min(canvas.width - treasure.width, treasure.x)
            );
            treasure.y = Math.max(
              0,
              Math.min(canvas.height - treasure.height, treasure.y)
            );
          }
        });
      }

      // Collision detection
      function checkCollisions() {
        // Check static treasure collection
        treasures.forEach((treasure) => {
          if (
            !treasure.collected &&
            player.x < treasure.x + treasure.width &&
            player.x + player.width > treasure.x &&
            player.y < treasure.y + treasure.height &&
            player.y + player.height > treasure.y
          ) {
            treasure.collected = true;
            gameState.treasuresCollected++;
            gameState.score += 100;

            if (gameState.treasuresCollected === 5) {
              gameState.gameWon = true;
              clearInterval(gameTimer);
              showVictoryMessage();
            }
          }
        });

        // Check moving treasure collection
        movingTreasures.forEach((treasure) => {
          if (
            !treasure.collected &&
            player.x < treasure.x + treasure.width &&
            player.x + player.width > treasure.x &&
            player.y < treasure.y + treasure.height &&
            player.y + player.height > treasure.y
          ) {
            treasure.collected = true;
            gameState.treasuresCollected++;
            gameState.score += 150; // Moving treasures worth more

            if (gameState.treasuresCollected === 5) {
              gameState.gameWon = true;
              clearInterval(gameTimer);
              showVictoryMessage();
            }
          }
        });

        // Check obstacle collisions
        obstacles.forEach((obstacle) => {
          if (
            player.x < obstacle.x + obstacle.width &&
            player.x + player.width > obstacle.x &&
            player.y < obstacle.y + obstacle.height &&
            player.y + player.height > obstacle.y
          ) {
            // Push player back
            if (player.x < obstacle.x) player.x = obstacle.x - player.width;
            if (player.x > obstacle.x) player.x = obstacle.x + obstacle.width;
            if (player.y < obstacle.y) player.y = obstacle.y - player.height;
            if (player.y > obstacle.y) player.y = obstacle.y + obstacle.height;
          }
        });

        // Check enemy collisions
        enemies.forEach((enemy) => {
          if (
            player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y
          ) {
            gameState.lives--;
            player.x = 50; // Reset player position
            player.y = 300;

            if (gameState.lives <= 0) {
              gameState.gameOver = true;
              clearInterval(gameTimer);
              setTimeout(restartGame, 2000);
            }
          }
        });
      }

      // Draw functions
      function drawPlayer() {
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.width, player.height);

        // Add simple face
        ctx.fillStyle = "white";
        ctx.fillRect(player.x + 8, player.y + 8, 4, 4);
        ctx.fillRect(player.x + 18, player.y + 8, 4, 4);
        ctx.fillRect(player.x + 10, player.y + 18, 10, 2);
      }

      function drawTreasures() {
        // Draw static treasures
        treasures.forEach((treasure) => {
          if (!treasure.collected) {
            ctx.fillStyle = "#f1c40f";
            ctx.fillRect(
              treasure.x,
              treasure.y,
              treasure.width,
              treasure.height
            );

            // Add shine effect
            ctx.fillStyle = "#fff";
            ctx.fillRect(treasure.x + 5, treasure.y + 5, 5, 5);
          }
        });

        // Draw moving treasures with different color
        movingTreasures.forEach((treasure) => {
          if (!treasure.collected) {
            ctx.fillStyle = "#e67e22"; // Orange for moving treasures
            ctx.fillRect(
              treasure.x,
              treasure.y,
              treasure.width,
              treasure.height
            );

            // Add shine effect
            ctx.fillStyle = "#fff";
            ctx.fillRect(treasure.x + 5, treasure.y + 5, 5, 5);

            // Add movement indicator
            ctx.fillStyle = "#d35400";
            ctx.fillRect(treasure.x + 2, treasure.y + 2, 3, 3);
          }
        });
      }

      function drawObstacles() {
        obstacles.forEach((obstacle) => {
          ctx.fillStyle = obstacle.color;
          ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

          // Add texture
          ctx.fillStyle = "#2c3e50";
          ctx.fillRect(
            obstacle.x + 5,
            obstacle.y + 5,
            obstacle.width - 10,
            obstacle.height - 10
          );
        });
      }

      function drawEnemies() {
        enemies.forEach((enemy) => {
          ctx.fillStyle = enemy.color;
          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

          // Add angry eyes
          ctx.fillStyle = "white";
          ctx.fillRect(enemy.x + 6, enemy.y + 6, 3, 3);
          ctx.fillRect(enemy.x + 16, enemy.y + 6, 3, 3);

          // Add indicator for following enemies
          if (enemy.followPlayer) {
            ctx.fillStyle = "#c0392b";
            ctx.fillRect(enemy.x + 10, enemy.y - 5, 5, 3);
          }
        });
      }

      function drawBackground() {
        // Create a simple pattern
        ctx.fillStyle = "rgba(52, 73, 94, 0.1)";
        for (let i = 0; i < canvas.width; i += 50) {
          for (let j = 0; j < canvas.height; j += 50) {
            ctx.fillRect(i, j, 2, 2);
          }
        }
      }

      function updateUI() {
        document.getElementById("score").textContent = gameState.score;
        document.getElementById("lives").textContent = gameState.lives;
        document.getElementById("treasures").textContent =
          gameState.treasuresCollected;
        document.getElementById("timer").textContent = gameState.timeLeft;
        document.getElementById("level").textContent = gameState.level;
      }

      function startTimer() {
        gameTimer = setInterval(() => {
          gameState.timeLeft--;
          if (gameState.timeLeft <= 0) {
            gameState.gameOver = true;
            clearInterval(gameTimer);
            setTimeout(restartGame, 2000);
          }
        }, 1000);
      }

      function showVictoryMessage() {
        document.getElementById("finalScore").textContent = gameState.score;
        document.getElementById("victoryMessage").style.display = "block";
      }

      function restartGame() {
        clearInterval(gameTimer);
        gameState = {
          score: 0,
          lives: 3,
          treasuresCollected: 0,
          gameWon: false,
          gameOver: false,
          level: 1,
          timeLeft: 60,
        };

        player.x = 50;
        player.y = 300;

        createTreasures();
        createEnemies();
        createObstacles();
        startTimer();

        document.getElementById("victoryMessage").style.display = "none";
      }

      // Game loop
      function gameLoop() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!gameState.gameWon && !gameState.gameOver) {
          // Update
          updatePlayer();
          updateEnemies();
          updateMovingTreasures();
          checkCollisions();

          // Draw
          drawBackground();
          drawObstacles();
          drawTreasures();
          drawEnemies();
          drawPlayer();

          // Update UI
          updateUI();
        } else if (gameState.gameOver) {
          // Game over screen
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = "white";
          ctx.font = "48px Arial";
          ctx.textAlign = "center";

          if (gameState.timeLeft <= 0) {
            ctx.fillText("Time Up!", canvas.width / 2, canvas.height / 2);
          } else {
            ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2);
          }

          ctx.font = "24px Arial";
          ctx.fillText(
            "Restarting...",
            canvas.width / 2,
            canvas.height / 2 + 60
          );
        }

        requestAnimationFrame(gameLoop);
      }

      // Initialize game
      createTreasures();
      createEnemies();
      createObstacles();
      startTimer();
      gameLoop();
    </script>
  </body>
</html>
